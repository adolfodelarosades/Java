# Step 06 - Writing Assertions for Arrays - `assertArrayEquals``

Bienvenido de nuevo. En este consejo, concentr√©monos en c√≥mo afirmar matrices. Si sus m√©todos est√°n devolviendo matrices, ¬øc√≥mo los prueba? Eso es lo que aprender√≠amos durante este paso. Pero antes de eso, tomemos un consejo r√°pido. Una de las cosas que est√°bamos haciendo hasta ahora es que en realidad est√°bamos escribiendo pruebas como resultado es igual a srt.contains("ijk"), y afirmamosFalso, resultado, ¬øverdad? Otra forma en que podr√≠as haber hecho esto es en l√≠nea, ¬øverdad? Entonces puedo hacer alt shift I o comando alt I. Puedes hacer un clic derecho, Refactorizar, y puedes decir en l√≠nea, y tambi√©n puedes hacerlo de esta manera. Por lo general, cuando escribimos una prueba unitaria, querr√° que sea realmente legible. Entonces, a veces puede ser m√°s f√°cil hacer cosas como esta. Entonces, esta prueba es mucho m√°s legible, por lo que contiene_basic () assertFalse () esto contiene ("ijk"), ¬øverdad? Entonces, algunas de las variables que est√°bamos creando anteriormente podr√≠an ser innecesarias. Debe pensar en qu√© hace que la prueba sea m√°s legible e intentar usar ese enfoque. Entonces, si cree que este enfoque es mucho m√°s legible que tratar de hacer este tipo de cosas, entonces es posible que prefiera hacer esto. De acuerdo, aparte de ese consejo, profundicemos en la afirmaci√≥n de matrices. Vamos a crear una nueva prueba. Uno de los m√©todos que devuelve matrices en cadena es split, a la derecha. As√≠ que eleg√≠ dividir y hagamos una divisi√≥n b√°sica. Consideremos que String str es igual a digamos abc def ghi, correcto. Y me gustar√≠a hacer una divisi√≥n de esto, as√≠ que str.split(). As√≠ que ahora eres el desarrollador del m√©todo split. As√≠ que has escrito el c√≥digo para ello. Quiere comprobar si funciona bien. Entonces no quiero verificar con pasar un espacio. Me gustar√≠a dividirlo con un espacio, [Sin audio] correcto. As√≠ que resultado, llam√©moslo resultado, entonces el resultado ser√° una matriz de cadenas con los valores divididos. ¬øCu√°l ser√≠a el valor esperado? El valor esperado ser√≠a una matriz, ¬øverdad? Entonces, el valor esperado ser√≠a una nueva matriz de cadenas, que tendr√≠a tres valores, ¬øverdad? As√≠ que "abc", "def". As√≠ que este ser√≠a el valor esperado. As√≠ que dir√© que el resultado esperado de la cadena es igual a este, y este es el resultado real, ¬øverdad? Entonces, el resultado esperado es un conjunto de matrices. En realidad, hay una matriz de cadenas. As√≠ que pongamos la matriz aqu√≠ para hacer feliz al compilador. En Java 10, realmente no necesitamos hacer esto tambi√©n. Solo podemos decir que se trata de una var, pero esperemos a que aparezca. Ahora, aqu√≠, puedo decir assetEquals(), no, si desea afirmar matrices, necesita usar assertArrayEquals(). Entonces puede decir afirmarArrayEquals (resultado real, resultado esperado). [Sin audio] Genial, ¬øverdad? Ahora hagamos esta prueba. Enfriar. La prueba tiene √©xito. Puedes pausar el video aqu√≠. Hay un peque√±o error que he cometido. As√≠ que puedes intentar pausar el video aqu√≠ e intentar encontrar de qu√© se trata. La cosa siempre es que lo esperado debe ser el primero, y lo real debe ser el segundo par√°metro. ¬øPor qu√© es eso importante? Porque si ahora digo abc1. Entonces esta prueba comenzar√≠a a fallar, ¬øverdad? Esta prueba comenzar√≠a a fallar. Si hago un clic derecho, Run As, JUnit Test, ¬øqu√© suceder√≠a? Esta prueba comenzar√≠a a fallar. Pero lo importante es ¬øcu√°l es el mensaje que sale? Dice que la matriz contiene diferencias en el √≠ndice cero. Dice esperado abc1 pero era abc. Entonces dice que realResult es abc pero esperaba abc1. ¬øDerecha? Entonces, si cambio esto, ¬øqu√© suceder√≠a? Si tengo lo real como el primero y lo esperado como el segundo, ¬øqu√© pasar√≠a? Hagamos esta prueba y descubramos. Haga clic derecho, Ejecutar como, Prueba JUnit, puede ver que dice abc esperado pero era abc1. Esto no es cierto porque espero abc1 y el resultado real fue abc. Muy bien, es muy importante asegurarse de que su esperado sea el primer par√°metro que se pasa. Bien, una vez que hagas esto, puedes ver que la afirmaci√≥n de la matriz es genial. La aserci√≥n de matriz es genial porque te dice exactamente qu√© valor es diferente. Y entonces dice en el √≠ndice 0 abc1 que estoy esperando, pero era ABC. Ahora, si cambia esto y digamos que hubo un valor menos de lo que esper√°bamos. As√≠ que vamos a ver cu√°l ser√≠a el resultado. Haga clic derecho, Ejecutar como, Prueba JUnit. [Sin audio] Entonces dice que esperaba 2 pero eran 3, ¬øverdad? Eso es genial. Est√° diciendo que las longitudes de las matrices son diferentes. Por lo tanto, es muy f√°cil volver a la l√≠nea que arroja el error. Entonces puede hacer doble clic aqu√≠ y lo llevar√° a la afirmaci√≥n exacta esperada que est√° fallando. Lo que pasa con assertArrayEquals() es que te da una descripci√≥n impresionante cuando algo no est√° bien. Arreglemos la prueba para asegurarnos de que est√° pasando y ejecutemos esto, genial. La prueba tiene √©xito y eso es incre√≠ble, ¬øverdad? As√≠ que vamos a formatearlo un poco, y si quieres hacer algo de este tipo, tambi√©n est√° bien, en l√≠nea. As√≠ que hago clic derecho, Refactorizar, en l√≠nea. En este escenario, de alguna manera no me gusta el hecho de que los valores est√°n directamente all√≠, as√≠ que prefer√≠ el enfoque anterior. As√≠ que dejar√© la prueba como est√° aqu√≠. Siempre siga pensando en qu√© hace que la prueba sea m√°s legible para usted. Cada vez que escribe una prueba, el primer objectivo es asegurarse de que est√° probando el c√≥digo bajo prueba, ¬øverdad? Por lo tanto, debe asegurarse de que est√° probando el m√©todo de divisi√≥n correctamente. Una vez hecho esto, tambi√©n puede concentrarse en probar, ver si la prueba es legible. Cuando lo mire, cuando alguien m√°s lo mire, ¬øentender√° lo que la prueba est√° tratando de hacer? Y te ver√© en el siguiente paso. Hasta entonces, adi√≥s. [Sin aud
